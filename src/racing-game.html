<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æé€Ÿèµ›è½¦ - Racing Game</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            overflow: hidden;
        }

        #gameContainer {
            text-align: center;
            background: rgba(255, 255, 255, 0.95);
            padding: 20px;
            border-radius: 20px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
        }

        h1 {
            color: #667eea;
            margin-bottom: 10px;
            font-size: 2.5em;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.1);
        }

        #gameCanvas {
            border: 4px solid #667eea;
            border-radius: 10px;
            background: #2d3748;
            display: block;
            margin: 20px auto;
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.2);
        }

        #controls {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 20px;
            padding: 15px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-radius: 10px;
            color: white;
        }

        .info {
            font-size: 1.2em;
            font-weight: bold;
        }

        button {
            background: white;
            color: #667eea;
            border: none;
            padding: 12px 30px;
            font-size: 1.1em;
            font-weight: bold;
            border-radius: 25px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.3);
        }

        button:active {
            transform: translateY(0);
        }

        #instructions {
            margin-top: 15px;
            color: #555;
            font-size: 0.9em;
        }

        .emoji {
            font-size: 1.5em;
        }

        #gameOver {
            display: none;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 40px;
            border-radius: 15px;
            text-align: center;
            z-index: 100;
        }

        #gameOver h2 {
            font-size: 2.5em;
            margin-bottom: 20px;
            color: #ff6b6b;
        }

        #gameOver p {
            font-size: 1.5em;
            margin-bottom: 30px;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <h1>ğŸï¸ æé€Ÿèµ›è½¦ ğŸ</h1>
        <canvas id="gameCanvas" width="400" height="600"></canvas>
        <div id="controls">
            <div class="info">åˆ†æ•°: <span id="score">0</span></div>
            <button id="startBtn" onclick="startGame()">å¼€å§‹æ¸¸æˆ</button>
            <div class="info">é€Ÿåº¦: <span id="speed">1</span>x</div>
        </div>
        <div id="instructions">
            â¬…ï¸ æŒ‰ A æˆ– â† å·¦ç§» | æŒ‰ D æˆ– â†’ å³ç§» â¡ï¸<br>
            èº²é¿å…¶ä»–è½¦è¾†ï¼ŒåšæŒè¶Šä¹…åˆ†æ•°è¶Šé«˜ï¼
        </div>
    </div>

    <div id="gameOver">
        <h2>æ¸¸æˆç»“æŸï¼</h2>
        <p>æœ€ç»ˆåˆ†æ•°: <span id="finalScore">0</span></p>
        <button onclick="restartGame()" style="font-size: 1.2em;">å†æ¥ä¸€å±€</button>
    </div>

    <script>
        // ============================================
        // æ¸¸æˆé…ç½®å¸¸é‡
        // ============================================
        const CONFIG = {
            canvas: {
                width: 400,
                height: 600
            },
            road: {
                edgeWidth: 40,
                lineHeight: 40,
                lineGap: 20,
                lineWidth: 6,
                sideLineWidth: 4
            },
            player: {
                width: 40,
                height: 80,
                speed: 5,
                color: '#3498db',
                initialX: 200 - 20, // canvas.width / 2 - width / 2
                y: 600 - 120        // canvas.height - 120
            },
            obstacle: {
                width: 40,
                height: 80,
                colors: ['#e74c3c', '#f39c12', '#9b59b6', '#1abc9c', '#e67e22'],
                spawnRate: 0.02
            },
            game: {
                initialSpeed: 1,
                maxSpeed: 3,
                speedIncrement: 0.1,
                scorePerObstacle: 10,
                scoreForSpeedUp: 100
            },
            lanes: [80, 180, 280]  // ä¸‰æ¡è½¦é“çš„ x åæ ‡
        };

        // ============================================
        // DOM å…ƒç´ å¼•ç”¨
        // ============================================
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreElement = document.getElementById('score');
        const speedElement = document.getElementById('speed');
        const gameOverDiv = document.getElementById('gameOver');
        const finalScoreElement = document.getElementById('finalScore');

        // ============================================
        // æ¸¸æˆçŠ¶æ€
        // ============================================
        const gameState = {
            running: false,
            score: 0,
            speed: CONFIG.game.initialSpeed,
            animationId: null
        };

        // ============================================
        // æ¸¸æˆå¯¹è±¡
        // ============================================
        const player = {
            x: CONFIG.player.initialX,
            y: CONFIG.player.y,
            width: CONFIG.player.width,
            height: CONFIG.player.height,
            speed: CONFIG.player.speed,
            color: CONFIG.player.color
        };

        const roadLines = [];
        const obstacles = [];
        const keys = {};

        // ============================================
        // é“è·¯ç³»ç»Ÿ
        // ============================================

        // åˆå§‹åŒ–é“è·¯çº¿æ¡
        function initRoadLines() {
            roadLines.length = 0;
            const totalGap = CONFIG.road.lineHeight + CONFIG.road.lineGap;
            for (let i = -CONFIG.road.lineHeight; i < CONFIG.canvas.height; i += totalGap) {
                roadLines.push({ y: i });
            }
        }

        // ç»˜åˆ¶é™æ€é“è·¯èƒŒæ™¯ï¼ˆåªéœ€ç»˜åˆ¶ä¸€æ¬¡ï¼‰
        function drawStaticRoad() {
            // èƒŒæ™¯
            ctx.fillStyle = '#34495e';
            ctx.fillRect(0, 0, CONFIG.canvas.width, CONFIG.canvas.height);

            // é“è·¯è¾¹ç¼˜
            ctx.fillStyle = '#2c3e50';
            ctx.fillRect(0, 0, CONFIG.road.edgeWidth, CONFIG.canvas.height);
            ctx.fillRect(CONFIG.canvas.width - CONFIG.road.edgeWidth, 0, CONFIG.road.edgeWidth, CONFIG.canvas.height);
        }

        // ç»˜åˆ¶åŠ¨æ€é“è·¯çº¿æ¡
        function drawRoadLines() {
            const centerX = CONFIG.canvas.width / 2;
            const halfLineWidth = CONFIG.road.lineWidth / 2;

            // ä¸­å¿ƒçº¿ï¼ˆé»„è‰²ï¼‰
            ctx.fillStyle = '#f1c40f';
            for (let i = 0; i < roadLines.length; i++) {
                ctx.fillRect(centerX - halfLineWidth, roadLines[i].y, CONFIG.road.lineWidth, CONFIG.road.lineHeight);
            }

            // è¾¹çº¿ï¼ˆç™½è‰²ï¼‰
            ctx.fillStyle = '#ecf0f1';
            const leftLineX = 50;
            const rightLineX = CONFIG.canvas.width - 54;
            for (let i = 0; i < roadLines.length; i++) {
                ctx.fillRect(leftLineX, roadLines[i].y, CONFIG.road.sideLineWidth, CONFIG.road.lineHeight);
                ctx.fillRect(rightLineX, roadLines[i].y, CONFIG.road.sideLineWidth, CONFIG.road.lineHeight);
            }
        }

        // æ›´æ–°é“è·¯çº¿æ¡ä½ç½®
        function updateRoadLines() {
            const speed = 3 * gameState.speed;
            for (let i = 0; i < roadLines.length; i++) {
                roadLines[i].y += speed;
                if (roadLines[i].y > CONFIG.canvas.height) {
                    roadLines[i].y = -CONFIG.road.lineHeight;
                }
            }
        }

        // ============================================
        // è½¦è¾†æ¸²æŸ“ç³»ç»Ÿ
        // ============================================

        // ç»˜åˆ¶è½¦è¾†
        function drawCar(car) {
            const { x, y, width, height, color } = car;

            // è½¦èº«
            ctx.fillStyle = color;
            ctx.fillRect(x, y, width, height);

            // è½¦çª—
            ctx.fillStyle = 'rgba(52, 152, 219, 0.6)';
            ctx.fillRect(x + 5, y + 10, width - 10, height * 0.3);

            // è½¦è½®ï¼ˆä½¿ç”¨å¸¸é‡é¿å…é­”æ³•æ•°å­—ï¼‰
            const wheelWidth = 6;
            const wheelHeight = 15;
            ctx.fillStyle = '#2c3e50';
            // å‰å·¦è½®
            ctx.fillRect(x - 3, y + 15, wheelWidth, wheelHeight);
            // å‰å³è½®
            ctx.fillRect(x + width - 3, y + 15, wheelWidth, wheelHeight);
            // åå·¦è½®
            ctx.fillRect(x - 3, y + height - 30, wheelWidth, wheelHeight);
            // åå³è½®
            ctx.fillRect(x + width - 3, y + height - 30, wheelWidth, wheelHeight);

            // è½¦ç¯
            const lightWidth = 8;
            const lightHeight = 3;
            ctx.fillStyle = '#f1c40f';
            ctx.fillRect(x + 8, y + height - 5, lightWidth, lightHeight);
            ctx.fillRect(x + width - 16, y + height - 5, lightWidth, lightHeight);
        }

        // ============================================
        // éšœç¢ç‰©ç³»ç»Ÿ
        // ============================================

        // éšæœºé€‰æ‹©è½¦é“
        function getRandomLane() {
            return CONFIG.lanes[Math.floor(Math.random() * CONFIG.lanes.length)];
        }

        // éšæœºé€‰æ‹©é¢œè‰²
        function getRandomColor() {
            const colors = CONFIG.obstacle.colors;
            return colors[Math.floor(Math.random() * colors.length)];
        }

        // åˆ›å»ºéšœç¢ç‰©
        function createObstacle() {
            obstacles.push({
                x: getRandomLane(),
                y: -CONFIG.obstacle.height,
                width: CONFIG.obstacle.width,
                height: CONFIG.obstacle.height,
                color: getRandomColor()
            });
        }

        // æ›´æ–°éšœç¢ç‰©ä½ç½®å’ŒçŠ¶æ€
        function updateObstacles() {
            const speed = 4 * gameState.speed;

            // å€’åºéå†ï¼Œæ–¹ä¾¿åˆ é™¤
            for (let i = obstacles.length - 1; i >= 0; i--) {
                obstacles[i].y += speed;

                // ç§»é™¤è¶…å‡ºå±å¹•çš„éšœç¢ç‰©å¹¶å¢åŠ åˆ†æ•°
                if (obstacles[i].y > CONFIG.canvas.height) {
                    obstacles.splice(i, 1);
                    gameState.score += CONFIG.game.scorePerObstacle;
                    scoreElement.textContent = gameState.score;
                }
            }

            // æ ¹æ®é€Ÿåº¦åŠ¨æ€è°ƒæ•´ç”Ÿæˆç‡
            if (Math.random() < CONFIG.obstacle.spawnRate * gameState.speed) {
                createObstacle();
            }
        }

        // çŸ©å½¢ç¢°æ’æ£€æµ‹ï¼ˆAABBç®—æ³•ï¼‰
        function checkCollision(rect1, rect2) {
            return rect1.x < rect2.x + rect2.width &&
                   rect1.x + rect1.width > rect2.x &&
                   rect1.y < rect2.y + rect2.height &&
                   rect1.y + rect1.height > rect2.y;
        }

        // æ£€æµ‹ç©å®¶æ˜¯å¦ä¸ä»»ä½•éšœç¢ç‰©ç¢°æ’
        function checkPlayerCollision() {
            for (let i = 0; i < obstacles.length; i++) {
                if (checkCollision(player, obstacles[i])) {
                    return true;
                }
            }
            return false;
        }

        // ============================================
        // è¾“å…¥æ§åˆ¶ç³»ç»Ÿ
        // ============================================

        // é”®ç›˜äº‹ä»¶ç›‘å¬
        window.addEventListener('keydown', (e) => {
            keys[e.key] = true;
        });

        window.addEventListener('keyup', (e) => {
            keys[e.key] = false;
        });

        // æ£€æŸ¥æ˜¯å¦æŒ‰ä¸‹å·¦é”®
        function isLeftKeyPressed() {
            return keys['ArrowLeft'] || keys['a'] || keys['A'];
        }

        // æ£€æŸ¥æ˜¯å¦æŒ‰ä¸‹å³é”®
        function isRightKeyPressed() {
            return keys['ArrowRight'] || keys['d'] || keys['D'];
        }

        // æ›´æ–°ç©å®¶ä½ç½®
        function updatePlayer() {
            const leftBoundary = CONFIG.road.edgeWidth + 20;
            const rightBoundary = CONFIG.canvas.width - CONFIG.road.edgeWidth - CONFIG.player.width - 20;

            if (isLeftKeyPressed() && player.x > leftBoundary) {
                player.x -= player.speed;
            }
            if (isRightKeyPressed() && player.x < rightBoundary) {
                player.x += player.speed;
            }
        }

        // ============================================
        // éš¾åº¦ç³»ç»Ÿ
        // ============================================

        // åŠ¨æ€è°ƒæ•´æ¸¸æˆéš¾åº¦
        function updateDifficulty() {
            const { score } = gameState;
            const { scoreForSpeedUp, speedIncrement, maxSpeed } = CONFIG.game;

            if (score > 0 && score % scoreForSpeedUp === 0) {
                const newSpeed = Math.min(gameState.speed + speedIncrement, maxSpeed);
                if (newSpeed !== gameState.speed) {
                    gameState.speed = newSpeed;
                    speedElement.textContent = newSpeed.toFixed(1);
                }
            }
        }

        // ============================================
        // æ¸¸æˆä¸»å¾ªç¯
        // ============================================

        // æ¸²æŸ“æ‰€æœ‰æ¸¸æˆå¯¹è±¡
        function render() {
            // ç»˜åˆ¶é™æ€èƒŒæ™¯
            drawStaticRoad();

            // ç»˜åˆ¶åŠ¨æ€é“è·¯çº¿æ¡
            drawRoadLines();

            // ç»˜åˆ¶éšœç¢ç‰©
            for (let i = 0; i < obstacles.length; i++) {
                drawCar(obstacles[i]);
            }

            // ç»˜åˆ¶ç©å®¶
            drawCar(player);
        }

        // æ›´æ–°æ¸¸æˆçŠ¶æ€
        function update() {
            updateRoadLines();
            updateObstacles();
            updatePlayer();
            updateDifficulty();
        }

        // æ¸¸æˆä¸»å¾ªç¯
        function gameLoop() {
            if (!gameState.running) return;

            // æ›´æ–°æ¸¸æˆé€»è¾‘
            update();

            // ç¢°æ’æ£€æµ‹
            if (checkPlayerCollision()) {
                endGame();
                return;
            }

            // æ¸²æŸ“ç”»é¢
            render();

            // ç»§ç»­å¾ªç¯
            gameState.animationId = requestAnimationFrame(gameLoop);
        }

        // ============================================
        // æ¸¸æˆæµç¨‹æ§åˆ¶
        // ============================================

        // é‡ç½®æ¸¸æˆçŠ¶æ€
        function resetGameState() {
            gameState.score = 0;
            gameState.speed = CONFIG.game.initialSpeed;
            obstacles.length = 0;
            player.x = CONFIG.player.initialX;
        }

        // æ›´æ–°UIæ˜¾ç¤º
        function updateUI() {
            scoreElement.textContent = gameState.score;
            speedElement.textContent = gameState.speed.toFixed(1);
        }

        // å¼€å§‹æ¸¸æˆ
        function startGame() {
            if (gameState.running) return;

            // é‡ç½®çŠ¶æ€
            gameState.running = true;
            resetGameState();
            updateUI();

            // éšè—æ¸¸æˆç»“æŸç•Œé¢
            gameOverDiv.style.display = 'none';

            // åˆå§‹åŒ–é“è·¯
            initRoadLines();

            // æ›´æ–°æŒ‰é’®çŠ¶æ€
            const startBtn = document.getElementById('startBtn');
            startBtn.textContent = 'æ¸¸æˆä¸­...';
            startBtn.disabled = true;

            // å¯åŠ¨æ¸¸æˆå¾ªç¯
            gameLoop();
        }

        // ç»“æŸæ¸¸æˆ
        function endGame() {
            gameState.running = false;
            cancelAnimationFrame(gameState.animationId);

            // æ˜¾ç¤ºæœ€ç»ˆåˆ†æ•°
            finalScoreElement.textContent = gameState.score;
            gameOverDiv.style.display = 'block';

            // æ¢å¤æŒ‰é’®çŠ¶æ€
            const startBtn = document.getElementById('startBtn');
            startBtn.textContent = 'å¼€å§‹æ¸¸æˆ';
            startBtn.disabled = false;
        }

        // é‡æ–°å¼€å§‹æ¸¸æˆ
        function restartGame() {
            gameOverDiv.style.display = 'none';
            startGame();
        }

        // ============================================
        // æ¸¸æˆåˆå§‹åŒ–
        // ============================================
        (function init() {
            initRoadLines();
            drawStaticRoad();
            drawRoadLines();
            drawCar(player);
        })();
    </script>
</body>
</html>
